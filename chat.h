// **********************************************************************
//
// Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.6.3
//
// <auto-generated>
//
// Generated from file `chat.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __chat_h__
#define __chat_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Proxy.h>
#include <Ice/GCObject.h>
#include <Ice/AsyncResult.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <IceUtil/Optional.h>
#include <Ice/StreamF.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 306
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 3
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace Chat
{

class GroupServer;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Chat::GroupServer>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Chat::GroupServer*);

class GroupServerManager;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Chat::GroupServerManager>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Chat::GroupServerManager*);

class User;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Chat::User>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Chat::User*);

class ChatServer;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Chat::ChatServer>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Chat::ChatServer*);

}

}

namespace Chat
{

class GroupServer;
::Ice::Object* upCast(::Chat::GroupServer*);
typedef ::IceInternal::Handle< ::Chat::GroupServer> GroupServerPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Chat::GroupServer> GroupServerPrx;
void __patch(GroupServerPtr&, const ::Ice::ObjectPtr&);

class GroupServerManager;
::Ice::Object* upCast(::Chat::GroupServerManager*);
typedef ::IceInternal::Handle< ::Chat::GroupServerManager> GroupServerManagerPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Chat::GroupServerManager> GroupServerManagerPrx;
void __patch(GroupServerManagerPtr&, const ::Ice::ObjectPtr&);

class User;
::Ice::Object* upCast(::Chat::User*);
typedef ::IceInternal::Handle< ::Chat::User> UserPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Chat::User> UserPrx;
void __patch(UserPtr&, const ::Ice::ObjectPtr&);

class ChatServer;
::Ice::Object* upCast(::Chat::ChatServer*);
typedef ::IceInternal::Handle< ::Chat::ChatServer> ChatServerPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Chat::ChatServer> ChatServerPrx;
void __patch(ChatServerPtr&, const ::Ice::ObjectPtr&);

}

namespace Chat
{

class NameDoesNotExist : public ::Ice::UserException
{
public:

    NameDoesNotExist() {}
    virtual ~NameDoesNotExist() throw();

    virtual ::std::string ice_name() const;
    virtual NameDoesNotExist* ice_clone() const;
    virtual void ice_throw() const;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    using ::Ice::UserException::__writeImpl;
    using ::Ice::UserException::__readImpl;
};

static NameDoesNotExist __NameDoesNotExist_init;

class NameAlreadyExists : public ::Ice::UserException
{
public:

    NameAlreadyExists() {}
    virtual ~NameAlreadyExists() throw();

    virtual ::std::string ice_name() const;
    virtual NameAlreadyExists* ice_clone() const;
    virtual void ice_throw() const;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    using ::Ice::UserException::__writeImpl;
    using ::Ice::UserException::__readImpl;
};

class ServerAlreadyRegistered : public ::Ice::UserException
{
public:

    ServerAlreadyRegistered() {}
    virtual ~ServerAlreadyRegistered() throw();

    virtual ::std::string ice_name() const;
    virtual ServerAlreadyRegistered* ice_clone() const;
    virtual void ice_throw() const;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    using ::Ice::UserException::__writeImpl;
    using ::Ice::UserException::__readImpl;
};

class ServerDoesNotExist : public ::Ice::UserException
{
public:

    ServerDoesNotExist() {}
    virtual ~ServerDoesNotExist() throw();

    virtual ::std::string ice_name() const;
    virtual ServerDoesNotExist* ice_clone() const;
    virtual void ice_throw() const;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    using ::Ice::UserException::__writeImpl;
    using ::Ice::UserException::__readImpl;
};

class UserAlreadyRegistered : public ::Ice::UserException
{
public:

    UserAlreadyRegistered() {}
    virtual ~UserAlreadyRegistered() throw();

    virtual ::std::string ice_name() const;
    virtual UserAlreadyRegistered* ice_clone() const;
    virtual void ice_throw() const;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    using ::Ice::UserException::__writeImpl;
    using ::Ice::UserException::__readImpl;
};

class UserDoesNotExist : public ::Ice::UserException
{
public:

    UserDoesNotExist() {}
    virtual ~UserDoesNotExist() throw();

    virtual ::std::string ice_name() const;
    virtual UserDoesNotExist* ice_clone() const;
    virtual void ice_throw() const;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    using ::Ice::UserException::__writeImpl;
    using ::Ice::UserException::__readImpl;
};

typedef ::std::vector< ::Chat::GroupServerPrx> Groups;

typedef ::std::vector< ::Chat::UserPrx> Users;

}

namespace Ice
{
template<>
struct StreamableTraits< ::Chat::NameDoesNotExist>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Chat::NameAlreadyExists>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Chat::ServerAlreadyRegistered>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Chat::ServerDoesNotExist>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Chat::UserAlreadyRegistered>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Chat::UserDoesNotExist>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

}

namespace Chat
{

class Callback_ChatServer_LogIn_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatServer_LogIn_Base> Callback_ChatServer_LogInPtr;

class Callback_ChatServer_getUserByName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatServer_getUserByName_Base> Callback_ChatServer_getUserByNamePtr;

class Callback_ChatServer_GroupList_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatServer_GroupList_Base> Callback_ChatServer_GroupListPtr;

class Callback_ChatServer_getGroupServerByName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatServer_getGroupServerByName_Base> Callback_ChatServer_getGroupServerByNamePtr;

class Callback_ChatServer_CreateGroup_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatServer_CreateGroup_Base> Callback_ChatServer_CreateGroupPtr;

class Callback_ChatServer_DeleteGroup_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatServer_DeleteGroup_Base> Callback_ChatServer_DeleteGroupPtr;

class Callback_ChatServer_registerServer_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatServer_registerServer_Base> Callback_ChatServer_registerServerPtr;

class Callback_ChatServer_unregisterServer_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatServer_unregisterServer_Base> Callback_ChatServer_unregisterServerPtr;

class Callback_GroupServer_join_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GroupServer_join_Base> Callback_GroupServer_joinPtr;

class Callback_GroupServer_Leave_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GroupServer_Leave_Base> Callback_GroupServer_LeavePtr;

class Callback_GroupServer_SendMessage_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GroupServer_SendMessage_Base> Callback_GroupServer_SendMessagePtr;

class Callback_GroupServer_UserList_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GroupServer_UserList_Base> Callback_GroupServer_UserListPtr;

class Callback_GroupServer_Name_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GroupServer_Name_Base> Callback_GroupServer_NamePtr;

class Callback_GroupServerManager_CreateGroup_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GroupServerManager_CreateGroup_Base> Callback_GroupServerManager_CreateGroupPtr;

class Callback_GroupServerManager_ListGroups_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GroupServerManager_ListGroups_Base> Callback_GroupServerManager_ListGroupsPtr;

class Callback_GroupServerManager_DeleteGroup_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GroupServerManager_DeleteGroup_Base> Callback_GroupServerManager_DeleteGroupPtr;

class Callback_GroupServerManager_getGroupServerByName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GroupServerManager_getGroupServerByName_Base> Callback_GroupServerManager_getGroupServerByNamePtr;

class Callback_User_getName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_User_getName_Base> Callback_User_getNamePtr;

class Callback_User_receiveText_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_User_receiveText_Base> Callback_User_receiveTextPtr;

class Callback_User_receivePrivateText_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_User_receivePrivateText_Base> Callback_User_receivePrivateTextPtr;

}

namespace IceProxy
{

namespace Chat
{

class ChatServer : virtual public ::IceProxy::Ice::Object
{
public:

    void LogIn(const ::Chat::UserPrx& __p_callback)
    {
        LogIn(__p_callback, 0);
    }
    void LogIn(const ::Chat::UserPrx& __p_callback, const ::Ice::Context& __ctx)
    {
        LogIn(__p_callback, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_LogIn(const ::Chat::UserPrx& __p_callback, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_LogIn(__p_callback, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_LogIn(const ::Chat::UserPrx& __p_callback, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_LogIn(__p_callback, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_LogIn(const ::Chat::UserPrx& __p_callback, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_LogIn(__p_callback, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_LogIn(const ::Chat::UserPrx& __p_callback, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_LogIn(__p_callback, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_LogIn(const ::Chat::UserPrx& __p_callback, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_LogIn(const ::Chat::UserPrx& __p_callback)
    {
        return begin_LogIn(__p_callback, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_LogIn(const ::Chat::UserPrx& __p_callback, const ::Ice::Context& __ctx)
    {
        return begin_LogIn(__p_callback, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_LogIn(const ::Chat::UserPrx& __p_callback, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_LogIn(__p_callback, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_LogIn(const ::Chat::UserPrx& __p_callback, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_LogIn(__p_callback, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_LogIn(const ::Chat::UserPrx& __p_callback, const ::Chat::Callback_ChatServer_LogInPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_LogIn(__p_callback, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_LogIn(const ::Chat::UserPrx& __p_callback, const ::Ice::Context& __ctx, const ::Chat::Callback_ChatServer_LogInPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_LogIn(__p_callback, &__ctx, __del, __cookie);
    }

    void end_LogIn(const ::Ice::AsyncResultPtr&);
    
private:

    void LogIn(const ::Chat::UserPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_LogIn(const ::Chat::UserPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Chat::UserPrx getUserByName(const ::std::string& __p_name)
    {
        return getUserByName(__p_name, 0);
    }
    ::Chat::UserPrx getUserByName(const ::std::string& __p_name, const ::Ice::Context& __ctx)
    {
        return getUserByName(__p_name, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getUserByName(const ::std::string& __p_name, const ::IceInternal::Function<void (const ::Chat::UserPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getUserByName(__p_name, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getUserByName(const ::std::string& __p_name, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getUserByName(__p_name, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getUserByName(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Chat::UserPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getUserByName(__p_name, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getUserByName(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getUserByName(__p_name, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getUserByName(const ::std::string& __p_name, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Chat::UserPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getUserByName(const ::std::string& __p_name)
    {
        return begin_getUserByName(__p_name, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getUserByName(const ::std::string& __p_name, const ::Ice::Context& __ctx)
    {
        return begin_getUserByName(__p_name, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getUserByName(const ::std::string& __p_name, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUserByName(__p_name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUserByName(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUserByName(__p_name, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUserByName(const ::std::string& __p_name, const ::Chat::Callback_ChatServer_getUserByNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUserByName(__p_name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUserByName(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::Chat::Callback_ChatServer_getUserByNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUserByName(__p_name, &__ctx, __del, __cookie);
    }

    ::Chat::UserPrx end_getUserByName(const ::Ice::AsyncResultPtr&);
    
private:

    ::Chat::UserPrx getUserByName(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getUserByName(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Chat::Groups GroupList()
    {
        return GroupList(0);
    }
    ::Chat::Groups GroupList(const ::Ice::Context& __ctx)
    {
        return GroupList(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_GroupList(const ::IceInternal::Function<void (const ::Chat::Groups&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_GroupList(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_GroupList(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_GroupList(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_GroupList(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Chat::Groups&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_GroupList(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_GroupList(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_GroupList(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_GroupList(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Chat::Groups&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_GroupList()
    {
        return begin_GroupList(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GroupList(const ::Ice::Context& __ctx)
    {
        return begin_GroupList(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GroupList(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GroupList(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GroupList(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GroupList(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GroupList(const ::Chat::Callback_ChatServer_GroupListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GroupList(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GroupList(const ::Ice::Context& __ctx, const ::Chat::Callback_ChatServer_GroupListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GroupList(&__ctx, __del, __cookie);
    }

    ::Chat::Groups end_GroupList(const ::Ice::AsyncResultPtr&);
    
private:

    ::Chat::Groups GroupList(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_GroupList(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Chat::GroupServerPrx getGroupServerByName(const ::std::string& __p_name)
    {
        return getGroupServerByName(__p_name, 0);
    }
    ::Chat::GroupServerPrx getGroupServerByName(const ::std::string& __p_name, const ::Ice::Context& __ctx)
    {
        return getGroupServerByName(__p_name, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getGroupServerByName(const ::std::string& __p_name, const ::IceInternal::Function<void (const ::Chat::GroupServerPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getGroupServerByName(__p_name, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getGroupServerByName(const ::std::string& __p_name, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getGroupServerByName(__p_name, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getGroupServerByName(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Chat::GroupServerPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getGroupServerByName(__p_name, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getGroupServerByName(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getGroupServerByName(__p_name, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getGroupServerByName(const ::std::string& __p_name, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Chat::GroupServerPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getGroupServerByName(const ::std::string& __p_name)
    {
        return begin_getGroupServerByName(__p_name, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getGroupServerByName(const ::std::string& __p_name, const ::Ice::Context& __ctx)
    {
        return begin_getGroupServerByName(__p_name, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getGroupServerByName(const ::std::string& __p_name, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getGroupServerByName(__p_name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getGroupServerByName(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getGroupServerByName(__p_name, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getGroupServerByName(const ::std::string& __p_name, const ::Chat::Callback_ChatServer_getGroupServerByNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getGroupServerByName(__p_name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getGroupServerByName(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::Chat::Callback_ChatServer_getGroupServerByNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getGroupServerByName(__p_name, &__ctx, __del, __cookie);
    }

    ::Chat::GroupServerPrx end_getGroupServerByName(const ::Ice::AsyncResultPtr&);
    
private:

    ::Chat::GroupServerPrx getGroupServerByName(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getGroupServerByName(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void CreateGroup(const ::std::string& __p_name)
    {
        CreateGroup(__p_name, 0);
    }
    void CreateGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx)
    {
        CreateGroup(__p_name, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_CreateGroup(const ::std::string& __p_name, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_CreateGroup(__p_name, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_CreateGroup(const ::std::string& __p_name, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_CreateGroup(__p_name, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_CreateGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_CreateGroup(__p_name, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_CreateGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_CreateGroup(__p_name, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_CreateGroup(const ::std::string& __p_name, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_CreateGroup(const ::std::string& __p_name)
    {
        return begin_CreateGroup(__p_name, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_CreateGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx)
    {
        return begin_CreateGroup(__p_name, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_CreateGroup(const ::std::string& __p_name, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_CreateGroup(__p_name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_CreateGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_CreateGroup(__p_name, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_CreateGroup(const ::std::string& __p_name, const ::Chat::Callback_ChatServer_CreateGroupPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_CreateGroup(__p_name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_CreateGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::Chat::Callback_ChatServer_CreateGroupPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_CreateGroup(__p_name, &__ctx, __del, __cookie);
    }

    void end_CreateGroup(const ::Ice::AsyncResultPtr&);
    
private:

    void CreateGroup(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_CreateGroup(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void DeleteGroup(const ::std::string& __p_name)
    {
        DeleteGroup(__p_name, 0);
    }
    void DeleteGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx)
    {
        DeleteGroup(__p_name, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_DeleteGroup(const ::std::string& __p_name, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_DeleteGroup(__p_name, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_DeleteGroup(const ::std::string& __p_name, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_DeleteGroup(__p_name, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_DeleteGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_DeleteGroup(__p_name, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_DeleteGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_DeleteGroup(__p_name, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_DeleteGroup(const ::std::string& __p_name, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_DeleteGroup(const ::std::string& __p_name)
    {
        return begin_DeleteGroup(__p_name, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_DeleteGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx)
    {
        return begin_DeleteGroup(__p_name, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_DeleteGroup(const ::std::string& __p_name, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_DeleteGroup(__p_name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_DeleteGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_DeleteGroup(__p_name, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_DeleteGroup(const ::std::string& __p_name, const ::Chat::Callback_ChatServer_DeleteGroupPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_DeleteGroup(__p_name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_DeleteGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::Chat::Callback_ChatServer_DeleteGroupPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_DeleteGroup(__p_name, &__ctx, __del, __cookie);
    }

    void end_DeleteGroup(const ::Ice::AsyncResultPtr&);
    
private:

    void DeleteGroup(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_DeleteGroup(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void registerServer(const ::Chat::GroupServerManagerPrx& __p_serverManager)
    {
        registerServer(__p_serverManager, 0);
    }
    void registerServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::Ice::Context& __ctx)
    {
        registerServer(__p_serverManager, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_registerServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_registerServer(__p_serverManager, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_registerServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_registerServer(__p_serverManager, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_registerServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_registerServer(__p_serverManager, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_registerServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_registerServer(__p_serverManager, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_registerServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_registerServer(const ::Chat::GroupServerManagerPrx& __p_serverManager)
    {
        return begin_registerServer(__p_serverManager, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_registerServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::Ice::Context& __ctx)
    {
        return begin_registerServer(__p_serverManager, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_registerServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_registerServer(__p_serverManager, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_registerServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_registerServer(__p_serverManager, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_registerServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::Chat::Callback_ChatServer_registerServerPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_registerServer(__p_serverManager, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_registerServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::Ice::Context& __ctx, const ::Chat::Callback_ChatServer_registerServerPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_registerServer(__p_serverManager, &__ctx, __del, __cookie);
    }

    void end_registerServer(const ::Ice::AsyncResultPtr&);
    
private:

    void registerServer(const ::Chat::GroupServerManagerPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_registerServer(const ::Chat::GroupServerManagerPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void unregisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager)
    {
        unregisterServer(__p_serverManager, 0);
    }
    void unregisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::Ice::Context& __ctx)
    {
        unregisterServer(__p_serverManager, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_unregisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_unregisterServer(__p_serverManager, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_unregisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_unregisterServer(__p_serverManager, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_unregisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_unregisterServer(__p_serverManager, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_unregisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_unregisterServer(__p_serverManager, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_unregisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_unregisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager)
    {
        return begin_unregisterServer(__p_serverManager, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unregisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::Ice::Context& __ctx)
    {
        return begin_unregisterServer(__p_serverManager, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unregisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unregisterServer(__p_serverManager, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unregisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unregisterServer(__p_serverManager, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unregisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::Chat::Callback_ChatServer_unregisterServerPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unregisterServer(__p_serverManager, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unregisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::Ice::Context& __ctx, const ::Chat::Callback_ChatServer_unregisterServerPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unregisterServer(__p_serverManager, &__ctx, __del, __cookie);
    }

    void end_unregisterServer(const ::Ice::AsyncResultPtr&);
    
private:

    void unregisterServer(const ::Chat::GroupServerManagerPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_unregisterServer(const ::Chat::GroupServerManagerPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<ChatServer> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_secure(bool __secure) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_invocationTimeout(int __timeout) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_invocationTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_twoway() const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_oneway() const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_batchOneway() const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_datagram() const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_batchDatagram() const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_compress(bool __compress) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_timeout(int __timeout) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class GroupServer : virtual public ::IceProxy::Ice::Object
{
public:

    void join(const ::Chat::UserPrx& __p_who)
    {
        join(__p_who, 0);
    }
    void join(const ::Chat::UserPrx& __p_who, const ::Ice::Context& __ctx)
    {
        join(__p_who, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_join(const ::Chat::UserPrx& __p_who, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_join(__p_who, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_join(const ::Chat::UserPrx& __p_who, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_join(__p_who, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_join(const ::Chat::UserPrx& __p_who, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_join(__p_who, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_join(const ::Chat::UserPrx& __p_who, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_join(__p_who, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_join(const ::Chat::UserPrx& __p_who, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_join(const ::Chat::UserPrx& __p_who)
    {
        return begin_join(__p_who, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_join(const ::Chat::UserPrx& __p_who, const ::Ice::Context& __ctx)
    {
        return begin_join(__p_who, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_join(const ::Chat::UserPrx& __p_who, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_join(__p_who, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_join(const ::Chat::UserPrx& __p_who, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_join(__p_who, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_join(const ::Chat::UserPrx& __p_who, const ::Chat::Callback_GroupServer_joinPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_join(__p_who, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_join(const ::Chat::UserPrx& __p_who, const ::Ice::Context& __ctx, const ::Chat::Callback_GroupServer_joinPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_join(__p_who, &__ctx, __del, __cookie);
    }

    void end_join(const ::Ice::AsyncResultPtr&);
    
private:

    void join(const ::Chat::UserPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_join(const ::Chat::UserPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void Leave(const ::Chat::UserPrx& __p_who)
    {
        Leave(__p_who, 0);
    }
    void Leave(const ::Chat::UserPrx& __p_who, const ::Ice::Context& __ctx)
    {
        Leave(__p_who, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_Leave(const ::Chat::UserPrx& __p_who, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_Leave(__p_who, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_Leave(const ::Chat::UserPrx& __p_who, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_Leave(__p_who, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_Leave(const ::Chat::UserPrx& __p_who, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_Leave(__p_who, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_Leave(const ::Chat::UserPrx& __p_who, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_Leave(__p_who, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_Leave(const ::Chat::UserPrx& __p_who, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_Leave(const ::Chat::UserPrx& __p_who)
    {
        return begin_Leave(__p_who, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_Leave(const ::Chat::UserPrx& __p_who, const ::Ice::Context& __ctx)
    {
        return begin_Leave(__p_who, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_Leave(const ::Chat::UserPrx& __p_who, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_Leave(__p_who, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_Leave(const ::Chat::UserPrx& __p_who, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_Leave(__p_who, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_Leave(const ::Chat::UserPrx& __p_who, const ::Chat::Callback_GroupServer_LeavePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_Leave(__p_who, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_Leave(const ::Chat::UserPrx& __p_who, const ::Ice::Context& __ctx, const ::Chat::Callback_GroupServer_LeavePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_Leave(__p_who, &__ctx, __del, __cookie);
    }

    void end_Leave(const ::Ice::AsyncResultPtr&);
    
private:

    void Leave(const ::Chat::UserPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_Leave(const ::Chat::UserPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void SendMessage(const ::std::string& __p_message, const ::Chat::UserPrx& __p_sender)
    {
        SendMessage(__p_message, __p_sender, 0);
    }
    void SendMessage(const ::std::string& __p_message, const ::Chat::UserPrx& __p_sender, const ::Ice::Context& __ctx)
    {
        SendMessage(__p_message, __p_sender, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_SendMessage(const ::std::string& __p_message, const ::Chat::UserPrx& __p_sender, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_SendMessage(__p_message, __p_sender, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_SendMessage(const ::std::string& __p_message, const ::Chat::UserPrx& __p_sender, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_SendMessage(__p_message, __p_sender, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_SendMessage(const ::std::string& __p_message, const ::Chat::UserPrx& __p_sender, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_SendMessage(__p_message, __p_sender, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_SendMessage(const ::std::string& __p_message, const ::Chat::UserPrx& __p_sender, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_SendMessage(__p_message, __p_sender, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_SendMessage(const ::std::string& __p_message, const ::Chat::UserPrx& __p_sender, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_SendMessage(const ::std::string& __p_message, const ::Chat::UserPrx& __p_sender)
    {
        return begin_SendMessage(__p_message, __p_sender, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SendMessage(const ::std::string& __p_message, const ::Chat::UserPrx& __p_sender, const ::Ice::Context& __ctx)
    {
        return begin_SendMessage(__p_message, __p_sender, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SendMessage(const ::std::string& __p_message, const ::Chat::UserPrx& __p_sender, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SendMessage(__p_message, __p_sender, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SendMessage(const ::std::string& __p_message, const ::Chat::UserPrx& __p_sender, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SendMessage(__p_message, __p_sender, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SendMessage(const ::std::string& __p_message, const ::Chat::UserPrx& __p_sender, const ::Chat::Callback_GroupServer_SendMessagePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SendMessage(__p_message, __p_sender, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SendMessage(const ::std::string& __p_message, const ::Chat::UserPrx& __p_sender, const ::Ice::Context& __ctx, const ::Chat::Callback_GroupServer_SendMessagePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SendMessage(__p_message, __p_sender, &__ctx, __del, __cookie);
    }

    void end_SendMessage(const ::Ice::AsyncResultPtr&);
    
private:

    void SendMessage(const ::std::string&, const ::Chat::UserPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_SendMessage(const ::std::string&, const ::Chat::UserPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Chat::Users UserList()
    {
        return UserList(0);
    }
    ::Chat::Users UserList(const ::Ice::Context& __ctx)
    {
        return UserList(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_UserList(const ::IceInternal::Function<void (const ::Chat::Users&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_UserList(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_UserList(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_UserList(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_UserList(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Chat::Users&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_UserList(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_UserList(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_UserList(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_UserList(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Chat::Users&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_UserList()
    {
        return begin_UserList(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_UserList(const ::Ice::Context& __ctx)
    {
        return begin_UserList(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_UserList(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_UserList(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_UserList(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_UserList(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_UserList(const ::Chat::Callback_GroupServer_UserListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_UserList(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_UserList(const ::Ice::Context& __ctx, const ::Chat::Callback_GroupServer_UserListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_UserList(&__ctx, __del, __cookie);
    }

    ::Chat::Users end_UserList(const ::Ice::AsyncResultPtr&);
    
private:

    ::Chat::Users UserList(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_UserList(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string Name()
    {
        return Name(0);
    }
    ::std::string Name(const ::Ice::Context& __ctx)
    {
        return Name(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_Name(const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_Name(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_Name(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_Name(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_Name(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_Name(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_Name(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_Name(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_Name(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_Name()
    {
        return begin_Name(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_Name(const ::Ice::Context& __ctx)
    {
        return begin_Name(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_Name(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_Name(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_Name(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_Name(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_Name(const ::Chat::Callback_GroupServer_NamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_Name(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_Name(const ::Ice::Context& __ctx, const ::Chat::Callback_GroupServer_NamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_Name(&__ctx, __del, __cookie);
    }

    ::std::string end_Name(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string Name(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_Name(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<GroupServer> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_secure(bool __secure) const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_invocationTimeout(int __timeout) const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_invocationTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_twoway() const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_oneway() const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_batchOneway() const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_datagram() const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_batchDatagram() const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_compress(bool __compress) const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_timeout(int __timeout) const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class GroupServerManager : virtual public ::IceProxy::Ice::Object
{
public:

    ::Chat::GroupServerPrx CreateGroup(const ::std::string& __p_name)
    {
        return CreateGroup(__p_name, 0);
    }
    ::Chat::GroupServerPrx CreateGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx)
    {
        return CreateGroup(__p_name, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_CreateGroup(const ::std::string& __p_name, const ::IceInternal::Function<void (const ::Chat::GroupServerPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_CreateGroup(__p_name, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_CreateGroup(const ::std::string& __p_name, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_CreateGroup(__p_name, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_CreateGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Chat::GroupServerPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_CreateGroup(__p_name, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_CreateGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_CreateGroup(__p_name, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_CreateGroup(const ::std::string& __p_name, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Chat::GroupServerPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_CreateGroup(const ::std::string& __p_name)
    {
        return begin_CreateGroup(__p_name, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_CreateGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx)
    {
        return begin_CreateGroup(__p_name, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_CreateGroup(const ::std::string& __p_name, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_CreateGroup(__p_name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_CreateGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_CreateGroup(__p_name, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_CreateGroup(const ::std::string& __p_name, const ::Chat::Callback_GroupServerManager_CreateGroupPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_CreateGroup(__p_name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_CreateGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::Chat::Callback_GroupServerManager_CreateGroupPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_CreateGroup(__p_name, &__ctx, __del, __cookie);
    }

    ::Chat::GroupServerPrx end_CreateGroup(const ::Ice::AsyncResultPtr&);
    
private:

    ::Chat::GroupServerPrx CreateGroup(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_CreateGroup(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Chat::Groups ListGroups()
    {
        return ListGroups(0);
    }
    ::Chat::Groups ListGroups(const ::Ice::Context& __ctx)
    {
        return ListGroups(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_ListGroups(const ::IceInternal::Function<void (const ::Chat::Groups&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_ListGroups(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_ListGroups(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_ListGroups(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_ListGroups(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Chat::Groups&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_ListGroups(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_ListGroups(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_ListGroups(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_ListGroups(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Chat::Groups&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_ListGroups()
    {
        return begin_ListGroups(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ListGroups(const ::Ice::Context& __ctx)
    {
        return begin_ListGroups(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ListGroups(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ListGroups(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ListGroups(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ListGroups(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ListGroups(const ::Chat::Callback_GroupServerManager_ListGroupsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ListGroups(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ListGroups(const ::Ice::Context& __ctx, const ::Chat::Callback_GroupServerManager_ListGroupsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ListGroups(&__ctx, __del, __cookie);
    }

    ::Chat::Groups end_ListGroups(const ::Ice::AsyncResultPtr&);
    
private:

    ::Chat::Groups ListGroups(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_ListGroups(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void DeleteGroup(const ::std::string& __p_name)
    {
        DeleteGroup(__p_name, 0);
    }
    void DeleteGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx)
    {
        DeleteGroup(__p_name, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_DeleteGroup(const ::std::string& __p_name, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_DeleteGroup(__p_name, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_DeleteGroup(const ::std::string& __p_name, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_DeleteGroup(__p_name, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_DeleteGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_DeleteGroup(__p_name, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_DeleteGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_DeleteGroup(__p_name, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_DeleteGroup(const ::std::string& __p_name, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_DeleteGroup(const ::std::string& __p_name)
    {
        return begin_DeleteGroup(__p_name, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_DeleteGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx)
    {
        return begin_DeleteGroup(__p_name, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_DeleteGroup(const ::std::string& __p_name, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_DeleteGroup(__p_name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_DeleteGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_DeleteGroup(__p_name, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_DeleteGroup(const ::std::string& __p_name, const ::Chat::Callback_GroupServerManager_DeleteGroupPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_DeleteGroup(__p_name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_DeleteGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::Chat::Callback_GroupServerManager_DeleteGroupPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_DeleteGroup(__p_name, &__ctx, __del, __cookie);
    }

    void end_DeleteGroup(const ::Ice::AsyncResultPtr&);
    
private:

    void DeleteGroup(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_DeleteGroup(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Chat::GroupServerPrx getGroupServerByName(const ::std::string& __p_name)
    {
        return getGroupServerByName(__p_name, 0);
    }
    ::Chat::GroupServerPrx getGroupServerByName(const ::std::string& __p_name, const ::Ice::Context& __ctx)
    {
        return getGroupServerByName(__p_name, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getGroupServerByName(const ::std::string& __p_name, const ::IceInternal::Function<void (const ::Chat::GroupServerPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getGroupServerByName(__p_name, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getGroupServerByName(const ::std::string& __p_name, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getGroupServerByName(__p_name, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getGroupServerByName(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Chat::GroupServerPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getGroupServerByName(__p_name, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getGroupServerByName(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getGroupServerByName(__p_name, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getGroupServerByName(const ::std::string& __p_name, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Chat::GroupServerPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getGroupServerByName(const ::std::string& __p_name)
    {
        return begin_getGroupServerByName(__p_name, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getGroupServerByName(const ::std::string& __p_name, const ::Ice::Context& __ctx)
    {
        return begin_getGroupServerByName(__p_name, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getGroupServerByName(const ::std::string& __p_name, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getGroupServerByName(__p_name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getGroupServerByName(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getGroupServerByName(__p_name, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getGroupServerByName(const ::std::string& __p_name, const ::Chat::Callback_GroupServerManager_getGroupServerByNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getGroupServerByName(__p_name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getGroupServerByName(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::Chat::Callback_GroupServerManager_getGroupServerByNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getGroupServerByName(__p_name, &__ctx, __del, __cookie);
    }

    ::Chat::GroupServerPrx end_getGroupServerByName(const ::Ice::AsyncResultPtr&);
    
private:

    ::Chat::GroupServerPrx getGroupServerByName(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getGroupServerByName(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_secure(bool __secure) const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_invocationTimeout(int __timeout) const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_invocationTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_twoway() const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_oneway() const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_batchOneway() const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_datagram() const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_batchDatagram() const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_compress(bool __compress) const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_timeout(int __timeout) const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class User : virtual public ::IceProxy::Ice::Object
{
public:

    ::std::string getName()
    {
        return getName(0);
    }
    ::std::string getName(const ::Ice::Context& __ctx)
    {
        return getName(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getName(const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getName(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getName(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getName(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getName(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getName(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getName(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getName(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getName(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getName()
    {
        return begin_getName(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context& __ctx)
    {
        return begin_getName(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getName(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getName(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Chat::Callback_User_getNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getName(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context& __ctx, const ::Chat::Callback_User_getNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getName(&__ctx, __del, __cookie);
    }

    ::std::string end_getName(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string getName(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void receiveText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Chat::GroupServerPrx& __p_gServer)
    {
        receiveText(__p_msg, __p_sender, __p_gServer, 0);
    }
    void receiveText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Chat::GroupServerPrx& __p_gServer, const ::Ice::Context& __ctx)
    {
        receiveText(__p_msg, __p_sender, __p_gServer, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_receiveText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Chat::GroupServerPrx& __p_gServer, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_receiveText(__p_msg, __p_sender, __p_gServer, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_receiveText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Chat::GroupServerPrx& __p_gServer, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_receiveText(__p_msg, __p_sender, __p_gServer, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_receiveText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Chat::GroupServerPrx& __p_gServer, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_receiveText(__p_msg, __p_sender, __p_gServer, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_receiveText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Chat::GroupServerPrx& __p_gServer, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_receiveText(__p_msg, __p_sender, __p_gServer, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_receiveText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Chat::GroupServerPrx& __p_gServer)
    {
        return begin_receiveText(__p_msg, __p_sender, __p_gServer, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_receiveText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Chat::GroupServerPrx& __p_gServer, const ::Ice::Context& __ctx)
    {
        return begin_receiveText(__p_msg, __p_sender, __p_gServer, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_receiveText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Chat::GroupServerPrx& __p_gServer, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_receiveText(__p_msg, __p_sender, __p_gServer, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_receiveText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Chat::GroupServerPrx& __p_gServer, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_receiveText(__p_msg, __p_sender, __p_gServer, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_receiveText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Chat::GroupServerPrx& __p_gServer, const ::Chat::Callback_User_receiveTextPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_receiveText(__p_msg, __p_sender, __p_gServer, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_receiveText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Chat::GroupServerPrx& __p_gServer, const ::Ice::Context& __ctx, const ::Chat::Callback_User_receiveTextPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_receiveText(__p_msg, __p_sender, __p_gServer, &__ctx, __del, __cookie);
    }

    void end_receiveText(const ::Ice::AsyncResultPtr&);
    
private:

    void receiveText(const ::std::string&, const ::Chat::UserPrx&, const ::Chat::GroupServerPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_receiveText(const ::std::string&, const ::Chat::UserPrx&, const ::Chat::GroupServerPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void receivePrivateText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender)
    {
        receivePrivateText(__p_msg, __p_sender, 0);
    }
    void receivePrivateText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Ice::Context& __ctx)
    {
        receivePrivateText(__p_msg, __p_sender, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_receivePrivateText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_receivePrivateText(__p_msg, __p_sender, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_receivePrivateText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_receivePrivateText(__p_msg, __p_sender, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_receivePrivateText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_receivePrivateText(__p_msg, __p_sender, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_receivePrivateText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_receivePrivateText(__p_msg, __p_sender, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_receivePrivateText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender)
    {
        return begin_receivePrivateText(__p_msg, __p_sender, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_receivePrivateText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Ice::Context& __ctx)
    {
        return begin_receivePrivateText(__p_msg, __p_sender, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_receivePrivateText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_receivePrivateText(__p_msg, __p_sender, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_receivePrivateText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_receivePrivateText(__p_msg, __p_sender, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_receivePrivateText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Chat::Callback_User_receivePrivateTextPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_receivePrivateText(__p_msg, __p_sender, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_receivePrivateText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Ice::Context& __ctx, const ::Chat::Callback_User_receivePrivateTextPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_receivePrivateText(__p_msg, __p_sender, &__ctx, __del, __cookie);
    }

    void end_receivePrivateText(const ::Ice::AsyncResultPtr&);
    
private:

    void receivePrivateText(const ::std::string&, const ::Chat::UserPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_receivePrivateText(const ::std::string&, const ::Chat::UserPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<User> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_secure(bool __secure) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_invocationTimeout(int __timeout) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_invocationTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_twoway() const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_oneway() const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_batchOneway() const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_datagram() const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_batchDatagram() const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_compress(bool __compress) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_timeout(int __timeout) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

namespace Chat
{

class ChatServer : virtual public ::Ice::Object
{
public:

    typedef ChatServerPrx ProxyType;
    typedef ChatServerPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void LogIn(const ::Chat::UserPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___LogIn(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Chat::UserPrx getUserByName(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getUserByName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Chat::Groups GroupList(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___GroupList(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Chat::GroupServerPrx getGroupServerByName(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getGroupServerByName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void CreateGroup(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___CreateGroup(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void DeleteGroup(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___DeleteGroup(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void registerServer(const ::Chat::GroupServerManagerPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___registerServer(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void unregisterServer(const ::Chat::GroupServerManagerPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___unregisterServer(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
};

inline bool operator==(const ChatServer& l, const ChatServer& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const ChatServer& l, const ChatServer& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class GroupServer : virtual public ::Ice::Object
{
public:

    typedef GroupServerPrx ProxyType;
    typedef GroupServerPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void join(const ::Chat::UserPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___join(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void Leave(const ::Chat::UserPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___Leave(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void SendMessage(const ::std::string&, const ::Chat::UserPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___SendMessage(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Chat::Users UserList(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___UserList(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string Name(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___Name(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
};

inline bool operator==(const GroupServer& l, const GroupServer& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const GroupServer& l, const GroupServer& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class GroupServerManager : virtual public ::Ice::Object
{
public:

    typedef GroupServerManagerPrx ProxyType;
    typedef GroupServerManagerPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::Chat::GroupServerPrx CreateGroup(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___CreateGroup(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Chat::Groups ListGroups(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___ListGroups(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void DeleteGroup(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___DeleteGroup(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Chat::GroupServerPrx getGroupServerByName(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getGroupServerByName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
};

inline bool operator==(const GroupServerManager& l, const GroupServerManager& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const GroupServerManager& l, const GroupServerManager& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class User : virtual public ::Ice::Object
{
public:

    typedef UserPrx ProxyType;
    typedef UserPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::std::string getName(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void receiveText(const ::std::string&, const ::Chat::UserPrx&, const ::Chat::GroupServerPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___receiveText(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void receivePrivateText(const ::std::string&, const ::Chat::UserPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___receivePrivateText(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
};

inline bool operator==(const User& l, const User& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const User& l, const User& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace Chat
{

template<class T>
class CallbackNC_ChatServer_LogIn : public Callback_ChatServer_LogIn_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ChatServer_LogIn(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_LogIn(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_ChatServer_LogInPtr
newCallback_ChatServer_LogIn(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_LogIn<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_LogInPtr
newCallback_ChatServer_LogIn(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_LogIn<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ChatServer_LogInPtr
newCallback_ChatServer_LogIn(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_LogIn<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_LogInPtr
newCallback_ChatServer_LogIn(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_LogIn<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatServer_LogIn : public Callback_ChatServer_LogIn_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ChatServer_LogIn(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_LogIn(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_ChatServer_LogInPtr
newCallback_ChatServer_LogIn(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_LogIn<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_LogInPtr
newCallback_ChatServer_LogIn(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_LogIn<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_LogInPtr
newCallback_ChatServer_LogIn(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_LogIn<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_LogInPtr
newCallback_ChatServer_LogIn(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_LogIn<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ChatServer_getUserByName : public Callback_ChatServer_getUserByName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Chat::UserPrx&);

    CallbackNC_ChatServer_getUserByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        ::Chat::UserPrx __ret;
        try
        {
            __ret = __proxy->end_getUserByName(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_ChatServer_getUserByNamePtr
newCallback_ChatServer_getUserByName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::UserPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_getUserByName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_getUserByNamePtr
newCallback_ChatServer_getUserByName(T* instance, void (T::*cb)(const ::Chat::UserPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_getUserByName<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatServer_getUserByName : public Callback_ChatServer_getUserByName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Chat::UserPrx&, const CT&);

    Callback_ChatServer_getUserByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        ::Chat::UserPrx __ret;
        try
        {
            __ret = __proxy->end_getUserByName(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_ChatServer_getUserByNamePtr
newCallback_ChatServer_getUserByName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::UserPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_getUserByName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_getUserByNamePtr
newCallback_ChatServer_getUserByName(T* instance, void (T::*cb)(const ::Chat::UserPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_getUserByName<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ChatServer_GroupList : public Callback_ChatServer_GroupList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Chat::Groups&);

    CallbackNC_ChatServer_GroupList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        ::Chat::Groups __ret;
        try
        {
            __ret = __proxy->end_GroupList(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_ChatServer_GroupListPtr
newCallback_ChatServer_GroupList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::Groups&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_GroupList<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_GroupListPtr
newCallback_ChatServer_GroupList(T* instance, void (T::*cb)(const ::Chat::Groups&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_GroupList<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatServer_GroupList : public Callback_ChatServer_GroupList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Chat::Groups&, const CT&);

    Callback_ChatServer_GroupList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        ::Chat::Groups __ret;
        try
        {
            __ret = __proxy->end_GroupList(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_ChatServer_GroupListPtr
newCallback_ChatServer_GroupList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::Groups&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_GroupList<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_GroupListPtr
newCallback_ChatServer_GroupList(T* instance, void (T::*cb)(const ::Chat::Groups&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_GroupList<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ChatServer_getGroupServerByName : public Callback_ChatServer_getGroupServerByName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Chat::GroupServerPrx&);

    CallbackNC_ChatServer_getGroupServerByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        ::Chat::GroupServerPrx __ret;
        try
        {
            __ret = __proxy->end_getGroupServerByName(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_ChatServer_getGroupServerByNamePtr
newCallback_ChatServer_getGroupServerByName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::GroupServerPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_getGroupServerByName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_getGroupServerByNamePtr
newCallback_ChatServer_getGroupServerByName(T* instance, void (T::*cb)(const ::Chat::GroupServerPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_getGroupServerByName<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatServer_getGroupServerByName : public Callback_ChatServer_getGroupServerByName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Chat::GroupServerPrx&, const CT&);

    Callback_ChatServer_getGroupServerByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        ::Chat::GroupServerPrx __ret;
        try
        {
            __ret = __proxy->end_getGroupServerByName(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_ChatServer_getGroupServerByNamePtr
newCallback_ChatServer_getGroupServerByName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::GroupServerPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_getGroupServerByName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_getGroupServerByNamePtr
newCallback_ChatServer_getGroupServerByName(T* instance, void (T::*cb)(const ::Chat::GroupServerPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_getGroupServerByName<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ChatServer_CreateGroup : public Callback_ChatServer_CreateGroup_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ChatServer_CreateGroup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_CreateGroup(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_ChatServer_CreateGroupPtr
newCallback_ChatServer_CreateGroup(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_CreateGroup<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_CreateGroupPtr
newCallback_ChatServer_CreateGroup(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_CreateGroup<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ChatServer_CreateGroupPtr
newCallback_ChatServer_CreateGroup(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_CreateGroup<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_CreateGroupPtr
newCallback_ChatServer_CreateGroup(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_CreateGroup<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatServer_CreateGroup : public Callback_ChatServer_CreateGroup_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ChatServer_CreateGroup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_CreateGroup(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_ChatServer_CreateGroupPtr
newCallback_ChatServer_CreateGroup(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_CreateGroup<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_CreateGroupPtr
newCallback_ChatServer_CreateGroup(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_CreateGroup<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_CreateGroupPtr
newCallback_ChatServer_CreateGroup(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_CreateGroup<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_CreateGroupPtr
newCallback_ChatServer_CreateGroup(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_CreateGroup<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ChatServer_DeleteGroup : public Callback_ChatServer_DeleteGroup_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ChatServer_DeleteGroup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_DeleteGroup(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_ChatServer_DeleteGroupPtr
newCallback_ChatServer_DeleteGroup(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_DeleteGroup<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_DeleteGroupPtr
newCallback_ChatServer_DeleteGroup(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_DeleteGroup<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ChatServer_DeleteGroupPtr
newCallback_ChatServer_DeleteGroup(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_DeleteGroup<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_DeleteGroupPtr
newCallback_ChatServer_DeleteGroup(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_DeleteGroup<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatServer_DeleteGroup : public Callback_ChatServer_DeleteGroup_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ChatServer_DeleteGroup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_DeleteGroup(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_ChatServer_DeleteGroupPtr
newCallback_ChatServer_DeleteGroup(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_DeleteGroup<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_DeleteGroupPtr
newCallback_ChatServer_DeleteGroup(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_DeleteGroup<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_DeleteGroupPtr
newCallback_ChatServer_DeleteGroup(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_DeleteGroup<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_DeleteGroupPtr
newCallback_ChatServer_DeleteGroup(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_DeleteGroup<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ChatServer_registerServer : public Callback_ChatServer_registerServer_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ChatServer_registerServer(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_registerServer(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_ChatServer_registerServerPtr
newCallback_ChatServer_registerServer(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_registerServer<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_registerServerPtr
newCallback_ChatServer_registerServer(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_registerServer<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ChatServer_registerServerPtr
newCallback_ChatServer_registerServer(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_registerServer<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_registerServerPtr
newCallback_ChatServer_registerServer(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_registerServer<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatServer_registerServer : public Callback_ChatServer_registerServer_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ChatServer_registerServer(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_registerServer(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_ChatServer_registerServerPtr
newCallback_ChatServer_registerServer(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_registerServer<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_registerServerPtr
newCallback_ChatServer_registerServer(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_registerServer<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_registerServerPtr
newCallback_ChatServer_registerServer(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_registerServer<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_registerServerPtr
newCallback_ChatServer_registerServer(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_registerServer<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ChatServer_unregisterServer : public Callback_ChatServer_unregisterServer_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ChatServer_unregisterServer(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_unregisterServer(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_ChatServer_unregisterServerPtr
newCallback_ChatServer_unregisterServer(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_unregisterServer<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_unregisterServerPtr
newCallback_ChatServer_unregisterServer(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_unregisterServer<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ChatServer_unregisterServerPtr
newCallback_ChatServer_unregisterServer(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_unregisterServer<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_unregisterServerPtr
newCallback_ChatServer_unregisterServer(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_unregisterServer<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatServer_unregisterServer : public Callback_ChatServer_unregisterServer_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ChatServer_unregisterServer(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_unregisterServer(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_ChatServer_unregisterServerPtr
newCallback_ChatServer_unregisterServer(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_unregisterServer<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_unregisterServerPtr
newCallback_ChatServer_unregisterServer(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_unregisterServer<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_unregisterServerPtr
newCallback_ChatServer_unregisterServer(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_unregisterServer<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_unregisterServerPtr
newCallback_ChatServer_unregisterServer(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_unregisterServer<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_GroupServer_join : public Callback_GroupServer_join_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_GroupServer_join(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::GroupServerPrx __proxy = ::Chat::GroupServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_join(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_GroupServer_joinPtr
newCallback_GroupServer_join(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_join<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServer_joinPtr
newCallback_GroupServer_join(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_join<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_GroupServer_joinPtr
newCallback_GroupServer_join(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_join<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServer_joinPtr
newCallback_GroupServer_join(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_join<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_GroupServer_join : public Callback_GroupServer_join_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_GroupServer_join(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::GroupServerPrx __proxy = ::Chat::GroupServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_join(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_GroupServer_joinPtr
newCallback_GroupServer_join(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_join<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServer_joinPtr
newCallback_GroupServer_join(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_join<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServer_joinPtr
newCallback_GroupServer_join(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_join<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServer_joinPtr
newCallback_GroupServer_join(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_join<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_GroupServer_Leave : public Callback_GroupServer_Leave_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_GroupServer_Leave(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::GroupServerPrx __proxy = ::Chat::GroupServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_Leave(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_GroupServer_LeavePtr
newCallback_GroupServer_Leave(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_Leave<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServer_LeavePtr
newCallback_GroupServer_Leave(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_Leave<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_GroupServer_LeavePtr
newCallback_GroupServer_Leave(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_Leave<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServer_LeavePtr
newCallback_GroupServer_Leave(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_Leave<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_GroupServer_Leave : public Callback_GroupServer_Leave_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_GroupServer_Leave(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::GroupServerPrx __proxy = ::Chat::GroupServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_Leave(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_GroupServer_LeavePtr
newCallback_GroupServer_Leave(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_Leave<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServer_LeavePtr
newCallback_GroupServer_Leave(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_Leave<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServer_LeavePtr
newCallback_GroupServer_Leave(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_Leave<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServer_LeavePtr
newCallback_GroupServer_Leave(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_Leave<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_GroupServer_SendMessage : public Callback_GroupServer_SendMessage_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_GroupServer_SendMessage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::GroupServerPrx __proxy = ::Chat::GroupServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_SendMessage(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_GroupServer_SendMessagePtr
newCallback_GroupServer_SendMessage(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_SendMessage<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServer_SendMessagePtr
newCallback_GroupServer_SendMessage(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_SendMessage<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_GroupServer_SendMessagePtr
newCallback_GroupServer_SendMessage(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_SendMessage<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServer_SendMessagePtr
newCallback_GroupServer_SendMessage(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_SendMessage<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_GroupServer_SendMessage : public Callback_GroupServer_SendMessage_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_GroupServer_SendMessage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::GroupServerPrx __proxy = ::Chat::GroupServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_SendMessage(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_GroupServer_SendMessagePtr
newCallback_GroupServer_SendMessage(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_SendMessage<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServer_SendMessagePtr
newCallback_GroupServer_SendMessage(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_SendMessage<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServer_SendMessagePtr
newCallback_GroupServer_SendMessage(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_SendMessage<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServer_SendMessagePtr
newCallback_GroupServer_SendMessage(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_SendMessage<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_GroupServer_UserList : public Callback_GroupServer_UserList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Chat::Users&);

    CallbackNC_GroupServer_UserList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::GroupServerPrx __proxy = ::Chat::GroupServerPrx::uncheckedCast(__result->getProxy());
        ::Chat::Users __ret;
        try
        {
            __ret = __proxy->end_UserList(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_GroupServer_UserListPtr
newCallback_GroupServer_UserList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::Users&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_UserList<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServer_UserListPtr
newCallback_GroupServer_UserList(T* instance, void (T::*cb)(const ::Chat::Users&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_UserList<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_GroupServer_UserList : public Callback_GroupServer_UserList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Chat::Users&, const CT&);

    Callback_GroupServer_UserList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::GroupServerPrx __proxy = ::Chat::GroupServerPrx::uncheckedCast(__result->getProxy());
        ::Chat::Users __ret;
        try
        {
            __ret = __proxy->end_UserList(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_GroupServer_UserListPtr
newCallback_GroupServer_UserList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::Users&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_UserList<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServer_UserListPtr
newCallback_GroupServer_UserList(T* instance, void (T::*cb)(const ::Chat::Users&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_UserList<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_GroupServer_Name : public Callback_GroupServer_Name_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_GroupServer_Name(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::GroupServerPrx __proxy = ::Chat::GroupServerPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_Name(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_GroupServer_NamePtr
newCallback_GroupServer_Name(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_Name<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServer_NamePtr
newCallback_GroupServer_Name(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_Name<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_GroupServer_Name : public Callback_GroupServer_Name_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_GroupServer_Name(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::GroupServerPrx __proxy = ::Chat::GroupServerPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_Name(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_GroupServer_NamePtr
newCallback_GroupServer_Name(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_Name<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServer_NamePtr
newCallback_GroupServer_Name(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_Name<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_GroupServerManager_CreateGroup : public Callback_GroupServerManager_CreateGroup_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Chat::GroupServerPrx&);

    CallbackNC_GroupServerManager_CreateGroup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::GroupServerManagerPrx __proxy = ::Chat::GroupServerManagerPrx::uncheckedCast(__result->getProxy());
        ::Chat::GroupServerPrx __ret;
        try
        {
            __ret = __proxy->end_CreateGroup(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_GroupServerManager_CreateGroupPtr
newCallback_GroupServerManager_CreateGroup(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::GroupServerPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServerManager_CreateGroup<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServerManager_CreateGroupPtr
newCallback_GroupServerManager_CreateGroup(T* instance, void (T::*cb)(const ::Chat::GroupServerPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServerManager_CreateGroup<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_GroupServerManager_CreateGroup : public Callback_GroupServerManager_CreateGroup_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Chat::GroupServerPrx&, const CT&);

    Callback_GroupServerManager_CreateGroup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::GroupServerManagerPrx __proxy = ::Chat::GroupServerManagerPrx::uncheckedCast(__result->getProxy());
        ::Chat::GroupServerPrx __ret;
        try
        {
            __ret = __proxy->end_CreateGroup(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_GroupServerManager_CreateGroupPtr
newCallback_GroupServerManager_CreateGroup(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::GroupServerPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServerManager_CreateGroup<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServerManager_CreateGroupPtr
newCallback_GroupServerManager_CreateGroup(T* instance, void (T::*cb)(const ::Chat::GroupServerPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServerManager_CreateGroup<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_GroupServerManager_ListGroups : public Callback_GroupServerManager_ListGroups_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Chat::Groups&);

    CallbackNC_GroupServerManager_ListGroups(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::GroupServerManagerPrx __proxy = ::Chat::GroupServerManagerPrx::uncheckedCast(__result->getProxy());
        ::Chat::Groups __ret;
        try
        {
            __ret = __proxy->end_ListGroups(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_GroupServerManager_ListGroupsPtr
newCallback_GroupServerManager_ListGroups(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::Groups&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServerManager_ListGroups<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServerManager_ListGroupsPtr
newCallback_GroupServerManager_ListGroups(T* instance, void (T::*cb)(const ::Chat::Groups&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServerManager_ListGroups<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_GroupServerManager_ListGroups : public Callback_GroupServerManager_ListGroups_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Chat::Groups&, const CT&);

    Callback_GroupServerManager_ListGroups(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::GroupServerManagerPrx __proxy = ::Chat::GroupServerManagerPrx::uncheckedCast(__result->getProxy());
        ::Chat::Groups __ret;
        try
        {
            __ret = __proxy->end_ListGroups(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_GroupServerManager_ListGroupsPtr
newCallback_GroupServerManager_ListGroups(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::Groups&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServerManager_ListGroups<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServerManager_ListGroupsPtr
newCallback_GroupServerManager_ListGroups(T* instance, void (T::*cb)(const ::Chat::Groups&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServerManager_ListGroups<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_GroupServerManager_DeleteGroup : public Callback_GroupServerManager_DeleteGroup_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_GroupServerManager_DeleteGroup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::GroupServerManagerPrx __proxy = ::Chat::GroupServerManagerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_DeleteGroup(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_GroupServerManager_DeleteGroupPtr
newCallback_GroupServerManager_DeleteGroup(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServerManager_DeleteGroup<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServerManager_DeleteGroupPtr
newCallback_GroupServerManager_DeleteGroup(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServerManager_DeleteGroup<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_GroupServerManager_DeleteGroupPtr
newCallback_GroupServerManager_DeleteGroup(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServerManager_DeleteGroup<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServerManager_DeleteGroupPtr
newCallback_GroupServerManager_DeleteGroup(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServerManager_DeleteGroup<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_GroupServerManager_DeleteGroup : public Callback_GroupServerManager_DeleteGroup_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_GroupServerManager_DeleteGroup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::GroupServerManagerPrx __proxy = ::Chat::GroupServerManagerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_DeleteGroup(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_GroupServerManager_DeleteGroupPtr
newCallback_GroupServerManager_DeleteGroup(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServerManager_DeleteGroup<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServerManager_DeleteGroupPtr
newCallback_GroupServerManager_DeleteGroup(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServerManager_DeleteGroup<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServerManager_DeleteGroupPtr
newCallback_GroupServerManager_DeleteGroup(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServerManager_DeleteGroup<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServerManager_DeleteGroupPtr
newCallback_GroupServerManager_DeleteGroup(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServerManager_DeleteGroup<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_GroupServerManager_getGroupServerByName : public Callback_GroupServerManager_getGroupServerByName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Chat::GroupServerPrx&);

    CallbackNC_GroupServerManager_getGroupServerByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::GroupServerManagerPrx __proxy = ::Chat::GroupServerManagerPrx::uncheckedCast(__result->getProxy());
        ::Chat::GroupServerPrx __ret;
        try
        {
            __ret = __proxy->end_getGroupServerByName(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_GroupServerManager_getGroupServerByNamePtr
newCallback_GroupServerManager_getGroupServerByName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::GroupServerPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServerManager_getGroupServerByName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServerManager_getGroupServerByNamePtr
newCallback_GroupServerManager_getGroupServerByName(T* instance, void (T::*cb)(const ::Chat::GroupServerPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServerManager_getGroupServerByName<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_GroupServerManager_getGroupServerByName : public Callback_GroupServerManager_getGroupServerByName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Chat::GroupServerPrx&, const CT&);

    Callback_GroupServerManager_getGroupServerByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::GroupServerManagerPrx __proxy = ::Chat::GroupServerManagerPrx::uncheckedCast(__result->getProxy());
        ::Chat::GroupServerPrx __ret;
        try
        {
            __ret = __proxy->end_getGroupServerByName(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_GroupServerManager_getGroupServerByNamePtr
newCallback_GroupServerManager_getGroupServerByName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::GroupServerPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServerManager_getGroupServerByName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServerManager_getGroupServerByNamePtr
newCallback_GroupServerManager_getGroupServerByName(T* instance, void (T::*cb)(const ::Chat::GroupServerPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServerManager_getGroupServerByName<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_User_getName : public Callback_User_getName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_User_getName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::UserPrx __proxy = ::Chat::UserPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getName(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_User_getNamePtr
newCallback_User_getName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_getName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_User_getNamePtr
newCallback_User_getName(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_getName<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_User_getName : public Callback_User_getName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_User_getName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::UserPrx __proxy = ::Chat::UserPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getName(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_User_getNamePtr
newCallback_User_getName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_getName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_User_getNamePtr
newCallback_User_getName(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_getName<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_User_receiveText : public Callback_User_receiveText_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_User_receiveText(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_User_receiveTextPtr
newCallback_User_receiveText(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_receiveText<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_User_receiveTextPtr
newCallback_User_receiveText(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_receiveText<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_User_receiveTextPtr
newCallback_User_receiveText(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_receiveText<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_User_receiveTextPtr
newCallback_User_receiveText(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_receiveText<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_User_receiveText : public Callback_User_receiveText_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_User_receiveText(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_User_receiveTextPtr
newCallback_User_receiveText(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_receiveText<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_User_receiveTextPtr
newCallback_User_receiveText(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_receiveText<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_User_receiveTextPtr
newCallback_User_receiveText(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_receiveText<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_User_receiveTextPtr
newCallback_User_receiveText(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_receiveText<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_User_receivePrivateText : public Callback_User_receivePrivateText_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_User_receivePrivateText(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_User_receivePrivateTextPtr
newCallback_User_receivePrivateText(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_receivePrivateText<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_User_receivePrivateTextPtr
newCallback_User_receivePrivateText(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_receivePrivateText<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_User_receivePrivateTextPtr
newCallback_User_receivePrivateText(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_receivePrivateText<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_User_receivePrivateTextPtr
newCallback_User_receivePrivateText(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_receivePrivateText<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_User_receivePrivateText : public Callback_User_receivePrivateText_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_User_receivePrivateText(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_User_receivePrivateTextPtr
newCallback_User_receivePrivateText(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_receivePrivateText<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_User_receivePrivateTextPtr
newCallback_User_receivePrivateText(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_receivePrivateText<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_User_receivePrivateTextPtr
newCallback_User_receivePrivateText(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_receivePrivateText<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_User_receivePrivateTextPtr
newCallback_User_receivePrivateText(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_receivePrivateText<T, CT>(instance, 0, excb, sentcb);
}

}

#include <IceUtil/PopDisableWarnings.h>
#endif
